(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{397:function(a,s,t){"use strict";t.r(s);var e=t(5),r=Object(e.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"使用技巧"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用技巧"}},[a._v("#")]),a._v(" 使用技巧")]),a._v(" "),s("h2",{attrs:{id:"使用-potplayer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用-potplayer"}},[a._v("#")]),a._v(" 使用 PotPlayer")]),a._v(" "),s("p",[a._v("PotPlayer 是一款 Windows 下十分强大的播放器，我默认生成的播放列表格式就是 PotPlayer 专用的播放列表格式 "),s("code",[a._v("dpl")]),a._v("，你可以使用 PotPlayer 直接打开它。")]),a._v(" "),s("p",[a._v("当然，我并不会强制你使用 PotPlayer（话说其它系统也没有 PotPlayer 的说），因此其它系统请使用"),s("a",{staticClass:"link-hover-effect absolute-link",attrs:{href:"../cli#%E6%8C%87%E5%AE%9A%E6%92%AD%E6%94%BE%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B"}},[a._v("参数 "),s("code",[a._v("--playlist-type")])]),a._v(" 进行修改。")]),a._v(" "),s("h2",{attrs:{id:"终端的选择"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#终端的选择"}},[a._v("#")]),a._v(" 终端的选择")]),a._v(" "),s("p",[a._v("请尽量使用支持 emoji 的终端，不然在我向你传达信息时可能出现失真问题（「乱码」现象），但这并不会影响下载过程。")]),a._v(" "),s("p",[a._v("Windows 比较推荐使用 「Windows Terminal」，或者如果你有 VS Code 这样的自带终端的编辑器也是可以直接使用其终端的。")]),a._v(" "),s("h2",{attrs:{id:"断点续传功能的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#断点续传功能的使用"}},[a._v("#")]),a._v(" 断点续传功能的使用")]),a._v(" "),s("p",[a._v("由于我具备断点续传的功能，因此你不必担心下载过程的中断，你可以在任何时刻 "),s("code",[a._v("Ctrl + C")]),a._v(" 中断下载，下一次重新启动只需要重新运行一下上次的命令即可。")]),a._v(" "),s("p",[a._v("当然你也可以在重新开始时修改一部分参数，但由于断点续传功能会依赖于本地已下载部分的大小直接接着下载，因此如果你在一次下载中途停止后，修改了 "),s("code",[a._v("type")]),a._v("、"),s("code",[a._v("block-size")]),a._v("、"),s("code",[a._v("quality")]),a._v(" 参数再次让我下载的话，两次下载的内容将截然不同，但断点续传机制仍然会强制拼接在一起，为了避免该问题，请在修改相关参数时删除已下载部分，或者直接添加参数 "),s("code",[a._v("overwrite")]),a._v(" 来自动完成该过程。")]),a._v(" "),s("h2",{attrs:{id:"升级方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#升级方式"}},[a._v("#")]),a._v(" 升级方式")]),a._v(" "),s("p",[a._v("如果你是通过 pip 安装我的话，那么只需要使用")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("pip "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("install")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--upgrade")]),a._v(" bilili\n")])])]),s("p",[a._v("而如果你是使用 git 直接安装，直接重新运行安装时所使用的命令即可。")]),a._v(" "),s("h2",{attrs:{id:"定义命令别名"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定义命令别名"}},[a._v("#")]),a._v(" 定义命令别名")]),a._v(" "),s("p",[a._v("可能你不想每次运行 bilili 都输入各种各样参数，所以这里我建议你将常用的参数都记录成在一条 alias 里，比如 Nyakku 就是这样做的")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("alias")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("bll")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'bilili -d ~/Movies/bilili/ -c `cat ~/.sessdata` --disable-proxy --danmaku=ass --playlist-type=m3u -y --use-mirrors'")]),a._v("\n")])])]),s("p",[a._v("由于 Nyakku 使用的是 zsh，将其存到 "),s("code",[a._v("~/.zshrc")]),a._v(" 就好了，如果你使用的是 bash 的话，存到 "),s("code",[a._v("~/.bashrc")]),a._v(" 就好。")]),a._v(" "),s("p",[a._v("当然，Nyakku 是将自己 Cookie 里的 SESSDATA 存到了 "),s("code",[a._v("~/.sessdata")]),a._v("，这样每次只需运行 bll 就可以省去定义存储目录、Cookie 等等的参数啦。")])])}),[],!1,null,null,null);s.default=r.exports}}]);